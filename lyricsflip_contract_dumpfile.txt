
### File: documents/lyricsflip_contract/manifest_dev.json ###
Type: json
Lines:     1512
Size: 41698 bytes

```json
{
  "world": {
    "class_hash": "0x45575a88cc5cef1e444c77ce60b7b4c9e73a01cbbe20926d5a4c72a94011410",
    "address": "0x525177c8afe8680d7ad1da30ca183e482cfcd6404c1e09d83fd3fa2994fd4b8",
    "seed": "lyricsflip",
    "name": "Dojo starter",
    "entrypoints": [
      "uuid",
      "set_metadata",
      "register_namespace",
      "register_event",
      "register_model",
      "register_contract",
      "init_contract",
      "upgrade_event",
      "upgrade_model",
      "upgrade_contract",
      "emit_event",
      "emit_events",
      "set_entity",
      "set_entities",
      "delete_entity",
      "delete_entities",
      "grant_owner",
      "revoke_owner",
      "grant_writer",
      "revoke_writer",
      "upgrade"
    ],
    "abi": [
      {
        "type": "impl",
        "name": "World",
        "interface_name": "dojo::world::iworld::IWorld"
      },
      {
        "type": "struct",
        "name": "core::byte_array::ByteArray",
        "members": [
          {
            "name": "data",
            "type": "core::array::Array::<core::bytes_31::bytes31>"
          },
          {
            "name": "pending_word",
            "type": "core::felt252"
          },
          {
            "name": "pending_word_len",
            "type": "core::integer::u32"
          }
        ]
      },
      {
        "type": "enum",
        "name": "dojo::world::resource::Resource",
        "variants": [
          {
            "name": "Model",
            "type": "(core::starknet::contract_address::ContractAddress, core::felt252)"
          },
          {
            "name": "Event",
            "type": "(core::starknet::contract_address::ContractAddress, core::felt252)"
          },
          {
            "name": "Contract",
            "type": "(core::starknet::contract_address::ContractAddress, core::felt252)"
          },
          {
            "name": "Namespace",
            "type": "core::byte_array::ByteArray"
          },
          {
            "name": "World",
            "type": "()"
          },
          {
            "name": "Unregistered",
            "type": "()"
          }
        ]
      },
      {
        "type": "struct",
        "name": "dojo::model::metadata::ResourceMetadata",
        "members": [
          {
            "name": "resource_id",
            "type": "core::felt252"
          },
          {
            "name": "metadata_uri",
            "type": "core::byte_array::ByteArray"
          },
          {
            "name": "metadata_hash",
            "type": "core::felt252"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<core::felt252>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<core::felt252>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<core::array::Span::<core::felt252>>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<core::array::Span::<core::felt252>>"
          }
        ]
      },
      {
        "type": "enum",
        "name": "dojo::model::definition::ModelIndex",
        "variants": [
          {
            "name": "Keys",
            "type": "core::array::Span::<core::felt252>"
          },
          {
            "name": "Id",
            "type": "core::felt252"
          },
          {
            "name": "MemberId",
            "type": "(core::felt252, core::felt252)"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<core::integer::u8>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<core::integer::u8>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "dojo::meta::layout::FieldLayout",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252"
          },
          {
            "name": "layout",
            "type": "dojo::meta::layout::Layout"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<dojo::meta::layout::FieldLayout>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<dojo::meta::layout::FieldLayout>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<dojo::meta::layout::Layout>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<dojo::meta::layout::Layout>"
          }
        ]
      },
      {
        "type": "enum",
        "name": "dojo::meta::layout::Layout",
        "variants": [
          {
            "name": "Fixed",
            "type": "core::array::Span::<core::integer::u8>"
          },
          {
            "name": "Struct",
            "type": "core::array::Span::<dojo::meta::layout::FieldLayout>"
          },
          {
            "name": "Tuple",
            "type": "core::array::Span::<dojo::meta::layout::Layout>"
          },
          {
            "name": "Array",
            "type": "core::array::Span::<dojo::meta::layout::Layout>"
          },
          {
            "name": "ByteArray",
            "type": "()"
          },
          {
            "name": "Enum",
            "type": "core::array::Span::<dojo::meta::layout::FieldLayout>"
          }
        ]
      },
      {
        "type": "struct",
        "name": "core::array::Span::<dojo::model::definition::ModelIndex>",
        "members": [
          {
            "name": "snapshot",
            "type": "@core::array::Array::<dojo::model::definition::ModelIndex>"
          }
        ]
      },
      {
        "type": "enum",
        "name": "core::bool",
        "variants": [
          {
            "name": "False",
            "type": "()"
          },
          {
            "name": "True",
            "type": "()"
          }
        ]
      },
      {
        "type": "interface",
        "name": "dojo::world::iworld::IWorld",
        "items": [
          {
            "type": "function",
            "name": "resource",
            "inputs": [
              {
                "name": "selector",
                "type": "core::felt252"
              }
            ],
            "outputs": [
              {
                "type": "dojo::world::resource::Resource"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "uuid",
            "inputs": [],
            "outputs": [
              {
                "type": "core::integer::u32"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "metadata",
            "inputs": [
              {
                "name": "resource_selector",
                "type": "core::felt252"
              }
            ],
            "outputs": [
              {
                "type": "dojo::model::metadata::ResourceMetadata"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "set_metadata",
            "inputs": [
              {
                "name": "metadata",
                "type": "dojo::model::metadata::ResourceMetadata"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_namespace",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_event",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_model",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "register_contract",
            "inputs": [
              {
                "name": "salt",
                "type": "core::felt252"
              },
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [
              {
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "init_contract",
            "inputs": [
              {
                "name": "selector",
                "type": "core::felt252"
              },
              {
                "name": "init_calldata",
                "type": "core::array::Span::<core::felt252>"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "upgrade_event",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "upgrade_model",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "upgrade_contract",
            "inputs": [
              {
                "name": "namespace",
                "type": "core::byte_array::ByteArray"
              },
              {
                "name": "class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [
              {
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "emit_event",
            "inputs": [
              {
                "name": "event_selector",
                "type": "core::felt252"
              },
              {
                "name": "keys",
                "type": "core::array::Span::<core::felt252>"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::felt252>"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "emit_events",
            "inputs": [
              {
                "name": "event_selector",
                "type": "core::felt252"
              },
              {
                "name": "keys",
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "entity",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "index",
                "type": "dojo::model::definition::ModelIndex"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [
              {
                "type": "core::array::Span::<core::felt252>"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "entities",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "indexes",
                "type": "core::array::Span::<dojo::model::definition::ModelIndex>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [
              {
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "set_entity",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "index",
                "type": "dojo::model::definition::ModelIndex"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::felt252>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "set_entities",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "indexes",
                "type": "core::array::Span::<dojo::model::definition::ModelIndex>"
              },
              {
                "name": "values",
                "type": "core::array::Span::<core::array::Span::<core::felt252>>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "delete_entity",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "index",
                "type": "dojo::model::definition::ModelIndex"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "delete_entities",
            "inputs": [
              {
                "name": "model_selector",
                "type": "core::felt252"
              },
              {
                "name": "indexes",
                "type": "core::array::Span::<dojo::model::definition::ModelIndex>"
              },
              {
                "name": "layout",
                "type": "dojo::meta::layout::Layout"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "is_owner",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "address",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [
              {
                "type": "core::bool"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "grant_owner",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "address",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "revoke_owner",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "address",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "is_writer",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "contract",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [
              {
                "type": "core::bool"
              }
            ],
            "state_mutability": "view"
          },
          {
            "type": "function",
            "name": "grant_writer",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "contract",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          },
          {
            "type": "function",
            "name": "revoke_writer",
            "inputs": [
              {
                "name": "resource",
                "type": "core::felt252"
              },
              {
                "name": "contract",
                "type": "core::starknet::contract_address::ContractAddress"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          }
        ]
      },
      {
        "type": "impl",
        "name": "UpgradeableWorld",
        "interface_name": "dojo::world::iworld::IUpgradeableWorld"
      },
      {
        "type": "interface",
        "name": "dojo::world::iworld::IUpgradeableWorld",
        "items": [
          {
            "type": "function",
            "name": "upgrade",
            "inputs": [
              {
                "name": "new_class_hash",
                "type": "core::starknet::class_hash::ClassHash"
              }
            ],
            "outputs": [],
            "state_mutability": "external"
          }
        ]
      },
      {
        "type": "constructor",
        "name": "constructor",
        "inputs": [
          {
            "name": "world_class_hash",
            "type": "core::starknet::class_hash::ClassHash"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::WorldSpawned",
        "kind": "struct",
        "members": [
          {
            "name": "creator",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::WorldUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::NamespaceRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "hash",
            "type": "core::felt252",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ModelRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::EventRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ContractRegistered",
        "kind": "struct",
        "members": [
          {
            "name": "name",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "namespace",
            "type": "core::byte_array::ByteArray",
            "kind": "key"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "salt",
            "type": "core::felt252",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ModelUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "prev_address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::EventUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          },
          {
            "name": "address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          },
          {
            "name": "prev_address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ContractUpgraded",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "class_hash",
            "type": "core::starknet::class_hash::ClassHash",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::ContractInitialized",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "init_calldata",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::EventEmitted",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "system_address",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "key"
          },
          {
            "name": "keys",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::MetadataUpdate",
        "kind": "struct",
        "members": [
          {
            "name": "resource",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "uri",
            "type": "core::byte_array::ByteArray",
            "kind": "data"
          },
          {
            "name": "hash",
            "type": "core::felt252",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreSetRecord",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "keys",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreUpdateRecord",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreUpdateMember",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "member_selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "values",
            "type": "core::array::Span::<core::felt252>",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::StoreDelRecord",
        "kind": "struct",
        "members": [
          {
            "name": "selector",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "entity_id",
            "type": "core::felt252",
            "kind": "key"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::WriterUpdated",
        "kind": "struct",
        "members": [
          {
            "name": "resource",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "contract",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "key"
          },
          {
            "name": "value",
            "type": "core::bool",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::OwnerUpdated",
        "kind": "struct",
        "members": [
          {
            "name": "resource",
            "type": "core::felt252",
            "kind": "key"
          },
          {
            "name": "contract",
            "type": "core::starknet::contract_address::ContractAddress",
            "kind": "key"
          },
          {
            "name": "value",
            "type": "core::bool",
            "kind": "data"
          }
        ]
      },
      {
        "type": "event",
        "name": "dojo::world::world_contract::world::Event",
        "kind": "enum",
        "variants": [
          {
            "name": "WorldSpawned",
            "type": "dojo::world::world_contract::world::WorldSpawned",
            "kind": "nested"
          },
          {
            "name": "WorldUpgraded",
            "type": "dojo::world::world_contract::world::WorldUpgraded",
            "kind": "nested"
          },
          {
            "name": "NamespaceRegistered",
            "type": "dojo::world::world_contract::world::NamespaceRegistered",
            "kind": "nested"
          },
          {
            "name": "ModelRegistered",
            "type": "dojo::world::world_contract::world::ModelRegistered",
            "kind": "nested"
          },
          {
            "name": "EventRegistered",
            "type": "dojo::world::world_contract::world::EventRegistered",
            "kind": "nested"
          },
          {
            "name": "ContractRegistered",
            "type": "dojo::world::world_contract::world::ContractRegistered",
            "kind": "nested"
          },
          {
            "name": "ModelUpgraded",
            "type": "dojo::world::world_contract::world::ModelUpgraded",
            "kind": "nested"
          },
          {
            "name": "EventUpgraded",
            "type": "dojo::world::world_contract::world::EventUpgraded",
            "kind": "nested"
          },
          {
            "name": "ContractUpgraded",
            "type": "dojo::world::world_contract::world::ContractUpgraded",
            "kind": "nested"
          },
          {
            "name": "ContractInitialized",
            "type": "dojo::world::world_contract::world::ContractInitialized",
            "kind": "nested"
          },
          {
            "name": "EventEmitted",
            "type": "dojo::world::world_contract::world::EventEmitted",
            "kind": "nested"
          },
          {
            "name": "MetadataUpdate",
            "type": "dojo::world::world_contract::world::MetadataUpdate",
            "kind": "nested"
          },
          {
            "name": "StoreSetRecord",
            "type": "dojo::world::world_contract::world::StoreSetRecord",
            "kind": "nested"
          },
          {
            "name": "StoreUpdateRecord",
            "type": "dojo::world::world_contract::world::StoreUpdateRecord",
            "kind": "nested"
          },
          {
            "name": "StoreUpdateMember",
            "type": "dojo::world::world_contract::world::StoreUpdateMember",
            "kind": "nested"
          },
          {
            "name": "StoreDelRecord",
            "type": "dojo::world::world_contract::world::StoreDelRecord",
            "kind": "nested"
          },
          {
            "name": "WriterUpdated",
            "type": "dojo::world::world_contract::world::WriterUpdated",
            "kind": "nested"
          },
          {
            "name": "OwnerUpdated",
            "type": "dojo::world::world_contract::world::OwnerUpdated",
            "kind": "nested"
          }
        ]
      }
    ]
  },
  "contracts": [
    {
      "address": "0x73a20bf1f5ebe9caf16bc08fb07434618300a55a764395a22f4fdde8237a547",
      "class_hash": "0x6cbb5ab40ad7b48dff70edeacc4902a9eeae63a9e36456f9f908aedb904fbd2",
      "abi": [
        {
          "type": "impl",
          "name": "actions__ContractImpl",
          "interface_name": "dojo::contract::interface::IContract"
        },
        {
          "type": "interface",
          "name": "dojo::contract::interface::IContract",
          "items": []
        },
        {
          "type": "impl",
          "name": "actions__DeployedContractImpl",
          "interface_name": "dojo::meta::interface::IDeployedResource"
        },
        {
          "type": "struct",
          "name": "core::byte_array::ByteArray",
          "members": [
            {
              "name": "data",
              "type": "core::array::Array::<core::bytes_31::bytes31>"
            },
            {
              "name": "pending_word",
              "type": "core::felt252"
            },
            {
              "name": "pending_word_len",
              "type": "core::integer::u32"
            }
          ]
        },
        {
          "type": "interface",
          "name": "dojo::meta::interface::IDeployedResource",
          "items": [
            {
              "type": "function",
              "name": "dojo_name",
              "inputs": [],
              "outputs": [
                {
                  "type": "core::byte_array::ByteArray"
                }
              ],
              "state_mutability": "view"
            }
          ]
        },
        {
          "type": "impl",
          "name": "ActionsImpl",
          "interface_name": "lyricsflip::systems::actions::IActions"
        },
        {
          "type": "enum",
          "name": "lyricsflip::models::Direction",
          "variants": [
            {
              "name": "Left",
              "type": "()"
            },
            {
              "name": "Right",
              "type": "()"
            },
            {
              "name": "Up",
              "type": "()"
            },
            {
              "name": "Down",
              "type": "()"
            }
          ]
        },
        {
          "type": "interface",
          "name": "lyricsflip::systems::actions::IActions",
          "items": [
            {
              "type": "function",
              "name": "spawn",
              "inputs": [],
              "outputs": [],
              "state_mutability": "external"
            },
            {
              "type": "function",
              "name": "move",
              "inputs": [
                {
                  "name": "direction",
                  "type": "lyricsflip::models::Direction"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            }
          ]
        },
        {
          "type": "function",
          "name": "dojo_init",
          "inputs": [],
          "outputs": [],
          "state_mutability": "view"
        },
        {
          "type": "impl",
          "name": "WorldProviderImpl",
          "interface_name": "dojo::contract::components::world_provider::IWorldProvider"
        },
        {
          "type": "struct",
          "name": "dojo::world::iworld::IWorldDispatcher",
          "members": [
            {
              "name": "contract_address",
              "type": "core::starknet::contract_address::ContractAddress"
            }
          ]
        },
        {
          "type": "interface",
          "name": "dojo::contract::components::world_provider::IWorldProvider",
          "items": [
            {
              "type": "function",
              "name": "world_dispatcher",
              "inputs": [],
              "outputs": [
                {
                  "type": "dojo::world::iworld::IWorldDispatcher"
                }
              ],
              "state_mutability": "view"
            }
          ]
        },
        {
          "type": "impl",
          "name": "UpgradeableImpl",
          "interface_name": "dojo::contract::components::upgradeable::IUpgradeable"
        },
        {
          "type": "interface",
          "name": "dojo::contract::components::upgradeable::IUpgradeable",
          "items": [
            {
              "type": "function",
              "name": "upgrade",
              "inputs": [
                {
                  "name": "new_class_hash",
                  "type": "core::starknet::class_hash::ClassHash"
                }
              ],
              "outputs": [],
              "state_mutability": "external"
            }
          ]
        },
        {
          "type": "constructor",
          "name": "constructor",
          "inputs": []
        },
        {
          "type": "event",
          "name": "dojo::contract::components::upgradeable::upgradeable_cpt::Upgraded",
          "kind": "struct",
          "members": [
            {
              "name": "class_hash",
              "type": "core::starknet::class_hash::ClassHash",
              "kind": "data"
            }
          ]
        },
        {
          "type": "event",
          "name": "dojo::contract::components::upgradeable::upgradeable_cpt::Event",
          "kind": "enum",
          "variants": [
            {
              "name": "Upgraded",
              "type": "dojo::contract::components::upgradeable::upgradeable_cpt::Upgraded",
              "kind": "nested"
            }
          ]
        },
        {
          "type": "event",
          "name": "dojo::contract::components::world_provider::world_provider_cpt::Event",
          "kind": "enum",
          "variants": []
        },
        {
          "type": "event",
          "name": "lyricsflip::systems::actions::actions::Event",
          "kind": "enum",
          "variants": [
            {
              "name": "UpgradeableEvent",
              "type": "dojo::contract::components::upgradeable::upgradeable_cpt::Event",
              "kind": "nested"
            },
            {
              "name": "WorldProviderEvent",
              "type": "dojo::contract::components::world_provider::world_provider_cpt::Event",
              "kind": "nested"
            }
          ]
        }
      ],
      "init_calldata": [],
      "tag": "lyricsflip-actions",
      "selector": "0x7a1c71029f2d0b38e3ac89b09931d08b6e48417e079c289ff19a8698d0cba33",
      "systems": [
        "spawn",
        "move",
        "upgrade"
      ]
    }
  ],
  "models": [
    {
      "members": [],
      "class_hash": "0x3f52c6cf17db224f4e7f88629adf7e907ff110baa0616c7e8ef17c5aecf1b1b",
      "tag": "lyricsflip-DirectionsAvailable",
      "selector": "0x77844f1facb51e60e546a9832d56c6bd04fa23be4fd5b57290caae5e9a3c1e4"
    },
    {
      "members": [],
      "class_hash": "0x5f79e21312b142fc289d3bd1e0f4c65ac3c4e532252c6fb1ad48b718d892dc",
      "tag": "lyricsflip-Moves",
      "selector": "0x2a29373f1af8348bd366a990eb3a342ef2cbe5e85160539eaca3441a673f468"
    },
    {
      "members": [],
      "class_hash": "0x2283c68ecba5c60bbbbd3b00659808a02244468e41a1d2cdba1312d65b83594",
      "tag": "lyricsflip-Position",
      "selector": "0x2ac8b4c190f7031b9fc44312e6b047a1dce0b3f2957c33a935ca7846a46dd5b"
    }
  ],
  "events": [
    {
      "members": [],
      "class_hash": "0x3dca5564f84050b20e66a2e5e7619201502d241b223ea73cfc05f29e6e20ea1",
      "tag": "lyricsflip-Moved",
      "selector": "0x504403e5c02b6442527721fc464d9ea5fc8f1ee600ab5ccd5c0845d36fd45f1"
    }
  ]
}```

----------------------------------------


### File: documents/lyricsflip_contract/dojo_release.toml ###
Type: toml
Lines:       26
Size: 1080 bytes

```toml
[world]
name = "Dojo starter"
description = "The official Dojo Starter guide, the quickest and most streamlined way to get your Dojo Autonomous World up and running. This guide will assist you with the initial setup, from cloning the repository to deploying your world."
cover_uri = "file://assets/cover.png"
icon_uri = "file://assets/icon.png"
website = "https://github.com/dojoengine/dojo-starter"
seed = "lyricsflip"

[world.socials]
x = "https://x.com/ohayo_dojo"
discord = "https://discord.gg/FB2wR6uF"
github = "https://github.com/dojoengine/dojo-starter"
telegram = "https://t.me/dojoengine"

[namespace]
default = "lyricsflip"

[env]
rpc_url = "http://localhost:5050/"
# Default account for katana with seed = 0
account_address = "0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec"
private_key = "0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912"
#world_address = "0x06171ed98331e849d6084bf2b3e3186a7ddf35574dd68cab4691053ee8ab69d7" # Uncomment and update this line with your world address.

[writers]
"lyricsflip" = ["lyricsflip-actions"]
```

----------------------------------------


### File: documents/lyricsflip_contract/README.md ###
Type: md
Lines:       15
Size: 194 bytes

```md
# lyricsflip_contract

### Build contract

```bash
sozo build 
```

### Run contract tests

Use the following command to run the tests for lyricsflip contracts

```bash
# Run tests
sozo test
``````

----------------------------------------


### File: documents/lyricsflip_contract/Scarb.toml ###
Type: toml
Lines:       21
Size: 523 bytes

```toml
[package]
cairo-version = "=2.9.2"
name = "lyricsflip"
version = "1.2.2"
edition = "2024_07"

[cairo]
sierra-replace-ids = true

[scripts]
migrate = "sozo build && sozo migrate"                      # scarb run migrate

[dependencies]
dojo = { git = "https://github.com/dojoengine/dojo", tag = "v1.2.2" }

[[target.starknet-contract]]
build-external-contracts = ["dojo::world::world_contract::world"]

[dev-dependencies]
cairo_test = "2.9.2"
dojo_cairo_test = { git = "https://github.com/dojoengine/dojo", tag = "v1.2.2" }
```

----------------------------------------


### File: documents/lyricsflip_contract/.github/workflows/test_contract.yml ###
Type: yml
Lines:       31
Size: 814 bytes

```yml
name: Contracts

on: [push, pull_request, workflow_dispatch]

permissions: read-all
  
jobs:
  sozo-test:
    runs-on: ubuntu-latest
    env:
      DOJO_VERSION: v1.2.2
    steps:
      - uses: actions/checkout@v3
      - uses: software-mansion/setup-scarb@v1
        with:
          scarb-version: "2.9.2"
      - run: |
          curl -L https://install.dojoengine.org | bash
          /home/runner/.config/.dojo/bin/dojoup -v ${{ env.DOJO_VERSION }}
      - run: |
          /home/runner/.config/.dojo/bin/sozo build
          /home/runner/.config/.dojo/bin/sozo test

  scarb-fmt:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: software-mansion/setup-scarb@v1
        with:
          scarb-version: "2.9.2"
      - name: Run scarb fmt check
        run: scarb fmt --check```

----------------------------------------


### File: documents/lyricsflip_contract/dojo_dev.toml ###
Type: toml
Lines:       26
Size: 1023 bytes

```toml
[world]
name = "Dojo starter"
description = "The official Dojo Starter guide, the quickest and most streamlined way to get your Dojo Autonomous World up and running. This guide will assist you with the initial setup, from cloning the repository to deploying your world."
cover_uri = "file://assets/cover.png"
icon_uri = "file://assets/icon.png"
website = "https://github.com/dojoengine/dojo-starter"
seed = "lyricsflip"

[world.socials]
x = "https://x.com/ohayo_dojo"
discord = "https://discord.gg/FB2wR6uF"
github = "https://github.com/dojoengine/dojo-starter"
telegram = "https://t.me/dojoengine"

[namespace]
default = "lyricsflip"

[env]
rpc_url = "http://localhost:5050/"
# Default account for katana with seed = 0
account_address = "0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec"
private_key = "0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912"
# world_address = "0x06171ed98331e849d6084bf2b3e3186a7ddf35574dd68cab4691053ee8ab69d7"

[writers]
"lyricsflip" = ["lyricsflip-actions"]
```

----------------------------------------


### File: documents/lyricsflip_contract/src/systems.cairo ###
Type: cairo
Lines:        2
Size: 33 bytes

```cairo
pub mod actions;
pub mod config;
```

----------------------------------------


### File: documents/lyricsflip_contract/src/models.cairo ###
Type: cairo
Lines:        3
Size: 45 bytes

```cairo
pub mod card;
pub mod config;
pub mod round;
```

----------------------------------------


### File: documents/lyricsflip_contract/src/tests/test_world.cairo ###
Type: cairo
Lines:      576
Size: 21718 bytes

```cairo
use starknet::testing;
use dojo::model::ModelStorage;
use dojo::world::{WorldStorage, WorldStorageTrait};
use lyricsflip::constants::{GAME_ID};
use lyricsflip::genre::{Genre};
use lyricsflip::models::config::{GameConfig};
use lyricsflip::models::round::{Rounds, RoundsCount, RoundPlayer, PlayerStats};
use lyricsflip::models::round::RoundState;
use lyricsflip::systems::actions::{IActionsDispatcher, IActionsDispatcherTrait, actions};
use lyricsflip::systems::config::{IGameConfigDispatcher, IGameConfigDispatcherTrait, game_config};
use lyricsflip::models::card::{LyricsCard, LyricsCardCount, YearCards, ArtistCards};

use lyricsflip::tests::test_utils::{setup};


#[test]
fn test_create_round() {
    let caller = starknet::contract_address_const::<0x0>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let round_id = actions_system.create_round(Genre::Rock.into());

    let res: Rounds = world.read_model(round_id);
    let rounds_count: RoundsCount = world.read_model(GAME_ID);

    assert(rounds_count.count == 1, 'rounds count is wrong');
    assert(res.round.creator == caller, 'round creator is wrong');
    assert(res.round.genre == Genre::Rock.into(), 'wrong round genre');
    assert(res.round.wager_amount == 0, 'wrong round wager_amount');
    assert(res.round.start_time == 0, 'wrong round start_time');
    assert(res.round.players_count == 1, 'wrong players_count');
    assert(res.round.state == RoundState::Pending.into(), 'Round state should be Pending');

    let round_id = actions_system.create_round(Genre::Pop.into());

    let res: Rounds = world.read_model(round_id);
    let rounds_count: RoundsCount = world.read_model(GAME_ID);
    let round_player: RoundPlayer = world.read_model((caller, round_id));

    assert(rounds_count.count == 2, 'rounds count should be 2');
    assert(res.round.creator == caller, 'round creator is wrong');
    assert(res.round.genre == Genre::Pop.into(), 'wrong round genre');
    assert(res.round.players_count == 1, 'wrong players_count');

    assert(round_player.joined, 'round not joined');
    assert(res.round.state == RoundState::Pending.into(), 'Round state should be Pending');
}

#[test]
fn test_join_round() {
    let caller = starknet::contract_address_const::<0x0>();
    let player = starknet::contract_address_const::<0x1>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let round_id = actions_system.create_round(Genre::Rock.into());

    let res: Rounds = world.read_model(round_id);
    assert(res.round.players_count == 1, 'wrong players_count');

    testing::set_contract_address(player);
    actions_system.join_round(round_id);

    let res: Rounds = world.read_model(round_id);
    let round_player: RoundPlayer = world.read_model((player, round_id));

    assert(res.round.players_count == 2, 'wrong players_count');
    assert(round_player.joined, 'player not joined');
}

#[test]
#[should_panic]
fn test_cannot_join_round_non_existent_round() {
    let caller = starknet::contract_address_const::<0x0>();
    let player = starknet::contract_address_const::<0x1>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    testing::set_caller_address(player);
    actions_system.join_round(1);
}

#[test]
#[should_panic]
fn test_cannot_join_ongoing_round() {
    let caller = starknet::contract_address_const::<0x0>();
    let player = starknet::contract_address_const::<0x1>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let round_id = actions_system.create_round(Genre::Rock.into());

    let mut res: Rounds = world.read_model(round_id);
    assert(res.round.players_count == 1, 'wrong players_count');

    res.round.state = RoundState::Started.into();
    world.write_model(@res);

    testing::set_contract_address(player);
    actions_system.join_round(round_id);
}

#[test]
#[should_panic]
fn test_cannot_join_already_joined_round() {
    let caller = starknet::contract_address_const::<0x0>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let round_id = actions_system.create_round(Genre::Rock.into());

    let mut res: Rounds = world.read_model(round_id);
    assert(res.round.players_count == 1, 'wrong players_count');

    actions_system.join_round(round_id);
}

#[test]
#[should_panic(expected: ('caller not admin', 'ENTRYPOINT_FAILED'))]
fn test_set_cards_per_round_non_admin() {
    let mut world = setup();

    let admin = starknet::contract_address_const::<0x1>();
    let _default_cards_per_round = 5_u32;

    world.write_model(@GameConfig { id: GAME_ID, cards_per_round: 5_u32, admin_address: admin });

    let (contract_address, _) = world.dns(@"game_config").unwrap();
    let game_config_system = IGameConfigDispatcher { contract_address };

    let new_cards_per_round = 10_u32;
    game_config_system.set_cards_per_round(new_cards_per_round);

    let config: GameConfig = world.read_model(GAME_ID);
    assert(config.cards_per_round == new_cards_per_round, 'cards_per_round not updated');
    assert(config.admin_address == admin, 'admin address changed');

    let another_value = 15_u32;
    game_config_system.set_cards_per_round(another_value);
    let config: GameConfig = world.read_model(GAME_ID);
    assert(config.cards_per_round == another_value, 'failed to update again');
}

#[test]
fn test_set_cards_per_round() {
    let mut world = setup();

    let admin = starknet::contract_address_const::<0x1>();
    let _default_cards_per_round = 5_u32;

    world.write_model(@GameConfig { id: GAME_ID, cards_per_round: 5_u32, admin_address: admin });

    let (contract_address, _) = world.dns(@"game_config").unwrap();
    let game_config_system = IGameConfigDispatcher { contract_address };

    testing::set_contract_address(admin);

    let new_cards_per_round = 10_u32;
    game_config_system.set_cards_per_round(new_cards_per_round);

    let config: GameConfig = world.read_model(GAME_ID);
    assert(config.cards_per_round == new_cards_per_round, 'cards_per_round not updated');
    assert(config.admin_address == admin, 'admin address changed');

    let another_value = 15_u32;
    game_config_system.set_cards_per_round(another_value);
    let config: GameConfig = world.read_model(GAME_ID);
    assert(config.cards_per_round == another_value, 'failed to update again');
}

#[test]
#[should_panic(expected: ('cards_per_round cannot be zero', 'ENTRYPOINT_FAILED'))]
fn test_set_cards_per_round_with_zero() {
    let mut world = setup();

    let admin = starknet::contract_address_const::<0x1>();
    world.write_model(@GameConfig { id: GAME_ID, cards_per_round: 5_u32, admin_address: admin });

    testing::set_contract_address(admin);

    let (contract_address, _) = world.dns(@"game_config").unwrap();
    let game_config_system = IGameConfigDispatcher { contract_address };

    game_config_system.set_cards_per_round(0);
}

#[test]
fn test_add_lyrics_card() {
    let mut world = setup();

    // Inicializamos LyricsCardCount
    world.write_model(@LyricsCardCount { id: GAME_ID, count: 0_u256 });

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let genre = Genre::Pop;
    let artist = 'fame';
    let title = 'sounds';
    let year = 2020;
    let lyrics: ByteArray = "come to life...";

    let card_id = actions_system.add_lyrics_card(genre, artist, title, year, lyrics.clone());

    // Verificamos el LyricsCard
    let card: LyricsCard = world.read_model(card_id);
    assert(card.card_id == 1_u256, 'wrong card_id');
    assert(card.genre == 'Pop', 'wrong genre');
    assert(card.artist == artist, 'wrong artist');
    assert(card.title == title, 'wrong title');
    assert(card.year == year, 'wrong year');
    assert(card.lyrics == lyrics, 'wrong lyrics');

    // Verificamos el LyricsCardCount
    let card_count: LyricsCardCount = world.read_model(GAME_ID);
    assert(card_count.count == 1_u256, 'wrong card count');

    // Verificamos el YearCards
    let year_cards: YearCards = world.read_model(year);
    assert(year_cards.year == year, 'wrong year in YearCards');
    assert(year_cards.cards.len() == 1, 'should have 1 card');
    assert(*year_cards.cards[0] == card_id, 'wrong card_id in YearCards');

    let artist_cards: ArtistCards = world.read_model(artist);
    assert(artist_cards.artist == artist, 'wrong artist in ArtistCards');
    assert(artist_cards.cards.len() == 1, 'should have 1 card');
    assert(*artist_cards.cards[0] == card_id, 'wrong card_id in ArtistCards');
}

#[test]
fn test_add_multiple_lyrics_cards_same_year() {
    let mut world = setup();

    // Inicializamos LyricsCardCount
    world.write_model(@LyricsCardCount { id: GAME_ID, count: 0_u256 });

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let year = 2020;
    let genre1 = Genre::Pop;
    let genre2 = Genre::Rock;
    let artist1 = 'artist1';
    let artist2 = 'artist2';
    let title1 = 'title1';
    let title2 = 'title2';
    let lyrics1: ByteArray = "lyrics for card 1";
    let lyrics2: ByteArray = "lyrics for card 2";

    // Agregamos la primera tarjeta
    let card_id1 = actions_system.add_lyrics_card(genre1, artist1, title1, year, lyrics1.clone());
    // Agregamos la segunda tarjeta en el mismo ao
    let card_id2 = actions_system.add_lyrics_card(genre2, artist2, title2, year, lyrics2.clone());

    // Verificamos los card_id
    assert(card_id1 == 1_u256, 'wrong card_id 1');
    assert(card_id2 == 2_u256, 'wrong card_id 2');

    // Verificamos el LyricsCardCount
    let card_count: LyricsCardCount = world.read_model(GAME_ID);
    assert(card_count.count == 2_u256, 'wrong card count');

    // Verificamos el YearCards
    let year_cards: YearCards = world.read_model(year);
    assert(year_cards.year == year, 'wrong year in YearCards');
    assert(year_cards.cards.len() == 2, 'should have 2 cards');
    assert(*year_cards.cards[0] == card_id1, 'wrong card_id 1 in YearCards');
    assert(*year_cards.cards[1] == card_id2, 'wrong card_id 2 in YearCards');
}

#[test]
fn test_add_lyrics_cards_different_years() {
    let mut world = setup();

    // Inicializamos LyricsCardCount
    world.write_model(@LyricsCardCount { id: GAME_ID, count: 0_u256 });

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let year1 = 2020;
    let year2 = 2021;
    let genre1 = Genre::Pop;
    let genre2 = Genre::Rock;
    let artist1 = 'artist1';
    let artist2 = 'artist2';
    let title1 = 'title1';
    let title2 = 'title2';
    let lyrics1: ByteArray = "lyrics for 2020";
    let lyrics2: ByteArray = "lyrics for 2021";

    // Agregamos la primera tarjeta (ao 2020)
    let card_id1 = actions_system.add_lyrics_card(genre1, artist1, title1, year1, lyrics1.clone());
    // Agregamos la segunda tarjeta (ao 2021)
    let card_id2 = actions_system.add_lyrics_card(genre2, artist2, title2, year2, lyrics2.clone());

    // Verificamos los card_id
    assert(card_id1 == 1_u256, 'wrong card_id 1');
    assert(card_id2 == 2_u256, 'wrong card_id 2');

    // Verificamos el LyricsCardCount
    let card_count: LyricsCardCount = world.read_model(GAME_ID);
    assert(card_count.count == 2_u256, 'wrong card count');

    // Verificamos el YearCards para el ao 2020
    let year_cards1: YearCards = world.read_model(year1);
    assert(year_cards1.year == year1, 'wrong year in YearCards 1');
    assert(year_cards1.cards.len() == 1, 'should have 1 card in 2020');
    assert(*year_cards1.cards[0] == card_id1, 'wrong card_id in YearCards 1');

    // Verificamos el YearCards para el ao 2021
    let year_cards2: YearCards = world.read_model(year2);
    assert(year_cards2.year == year2, 'wrong year in YearCards 2');
    assert(year_cards2.cards.len() == 1, 'should have 1 card in 2021');
    assert(*year_cards2.cards[0] == card_id2, 'wrong card_id in YearCards 2');
}

#[test]
fn test_set_admin_address() {
    let caller = starknet::contract_address_const::<0x1>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"game_config").unwrap();
    let actions_system = IGameConfigDispatcher { contract_address };

    actions_system.set_admin_address(caller);

    let config: GameConfig = world.read_model(GAME_ID);
    assert(config.admin_address == caller, 'admin_address not updated');
}

#[test]
#[should_panic(expected: ('admin_address cannot be zero', 'ENTRYPOINT_FAILED'))]
fn test_set_admin_address_panics_with_zero_address() {
    let caller = starknet::contract_address_const::<0x0>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"game_config").unwrap();
    let actions_system = IGameConfigDispatcher { contract_address };

    actions_system.set_admin_address(caller);
}

#[test]
fn test_get_round_id_initial_value() {
    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    world.write_model(@RoundsCount { id: GAME_ID, count: 5_u256 });

    let round_id = actions_system.get_round_id();

    assert(round_id == 6_u256, 'Initial round_id should be 6');

    let rounds_count: RoundsCount = world.read_model(GAME_ID);
    assert(rounds_count.count == 5_u256, 'rounds count should remain 5');
}

#[test]
fn test_round_id_consistency() {
    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let expected_round_id = actions_system.get_round_id();

    let actual_round_id = actions_system.create_round(Genre::Jazz.into());
    assert(actual_round_id == expected_round_id, 'Round IDs should match');

    let next_expected_id = actions_system.get_round_id();

    assert(next_expected_id == expected_round_id + 1_u256, 'Next ID should increment by 1');

    let next_actual_id = actions_system.create_round(Genre::Rock.into());
    assert(next_actual_id == next_expected_id, 'Next round IDs should match');

    let rounds_count: RoundsCount = world.read_model(GAME_ID);
    assert(rounds_count.count == 2_u256, 'rounds count should be 2');
}

#[test]
fn test_is_round_player_true() {
    let caller = starknet::contract_address_const::<0x0>();
    let player = starknet::contract_address_const::<0x1>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let round_id = actions_system.create_round(Genre::Rock.into());

    testing::set_contract_address(player);
    actions_system.join_round(round_id);

    let is_round_player = actions_system.is_round_player(round_id, player);

    assert(is_round_player, 'player not joined');
}

#[test]
fn test_is_round_player_false() {
    let caller = starknet::contract_address_const::<0x0>();
    let player = starknet::contract_address_const::<0x1>();

    let mut world = setup();

    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    let round_id = actions_system.create_round(Genre::Rock.into());
    let is_round_player = actions_system.is_round_player(round_id, player);

    assert(!is_round_player, 'player joined');
}


/// Test case: Attempting to start a round as a non-participant should fail
///
/// This test verifies that only participants (including the creator) can signal readiness.
/// The test should panic with the message "Caller is non participant".
#[test]
#[should_panic(expected: ('Caller is non participant', 'ENTRYPOINT_FAILED'))]
fn test_start_round_non_participant() {
    // Define test addresses
    let caller = starknet::contract_address_const::<0x0>(); // Non-participant address
    let player_1 = starknet::contract_address_const::<0x1>(); // Round creator 
    let player_2 = starknet::contract_address_const::<0x2>(); // Round participant

    // Initialize the test environment
    let mut world = setup();

    // Get the contract address for the actions system
    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    // Set player_1 as the current caller and create a new round
    testing::set_contract_address(player_1);
    let round_id = actions_system.create_round(Genre::Rock.into());

    // Set player_2 as the current caller and have them join the round
    testing::set_contract_address(player_2);
    actions_system.join_round(round_id);

    // Verify that the round has 2 players
    let res: Rounds = world.read_model(round_id);
    assert(res.round.players_count == 2, 'wrong players_count');

    // Set a non-participant address as the caller and attempt to start the round
    // This should fail with "Caller is non participant"
    testing::set_contract_address(caller);
    actions_system.start_round(round_id);
}


/// Test case: A player cannot signal readiness twice
///
/// This test verifies that a player cannot signal readiness more than once for the same round.
/// The test should panic with the message "Already signaled readiness".
#[test]
#[should_panic(expected: ('Already signaled readiness', 'ENTRYPOINT_FAILED'))]
fn test_start_round_already_ready() {
    // Define test addresses
    let caller = starknet::contract_address_const::<0x0>();
    let player_1 = starknet::contract_address_const::<0x1>();
    let player_2 = starknet::contract_address_const::<0x2>();

    // Initialize the test environment
    let mut world = setup();

    // Get the contract address for the actions system
    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    // Set player_1 as the current caller and create a new round
    testing::set_contract_address(player_1);
    let round_id = actions_system.create_round(Genre::Rock.into());

    // Set player_2 as the current caller and have them join the round
    testing::set_contract_address(player_2);
    actions_system.join_round(round_id);

    // Verify that the round has 2 players
    let res: Rounds = world.read_model(round_id);
    assert(res.round.players_count == 2, 'wrong players_count');

    // Player_2 signals readiness
    actions_system.start_round(round_id);

    // Player_2 tries to signal readiness again (should fail with "Already signaled readiness")
    actions_system.start_round(round_id);
}

/// Test case: Successfully starting a round when all players are ready
///
/// This test verifies the complete flow of starting a round:
/// 1. Two players join a round
/// 2. Both players signal readiness
/// 3. The round state changes to Started
/// 4. Player statistics are updated correctly
#[test]
fn test_start_round_ok() {
    // Define test addresses
    let caller = starknet::contract_address_const::<0x0>();
    let player_1 = starknet::contract_address_const::<0x1>(); // Round creator
    let player_2 = starknet::contract_address_const::<0x2>(); // Round participant

    // Initialize the test environment
    let mut world = setup();

    // Get the contract address for the actions system
    let (contract_address, _) = world.dns(@"actions").unwrap();
    let actions_system = IActionsDispatcher { contract_address };

    // Set player_1 as the current caller and create a new round
    testing::set_contract_address(player_1);
    let round_id = actions_system.create_round(Genre::Rock.into());

    // Set player_2 as the current caller and have them join the round
    testing::set_contract_address(player_2);
    actions_system.join_round(round_id);

    // Verify that the round has 2 players
    let res: Rounds = world.read_model(round_id);
    assert(res.round.players_count == 2, 'wrong players_count');

    // Player_1 signals readiness
    testing::set_contract_address(player_1);
    actions_system.start_round(round_id);

    // Player_2 signals readiness
    testing::set_contract_address(player_2);
    actions_system.start_round(round_id);

    // Verify the round is now in the Started state
    let rounds: Rounds = world.read_model(round_id);
    assert(rounds.round.state == RoundState::Started.into(), 'Round state should be Started');
    assert(rounds.round.ready_players_count == 2, 'wrong ready_players_count');

    // Verify player_1's ready state and statistics
    let round_player_1: RoundPlayer = world.read_model((player_1, round_id));
    assert(round_player_1.ready_state, 'player_1 should be ready');

    // Verify player_2's ready state and statistics
    let round_player_2: RoundPlayer = world.read_model((player_2, round_id));
    assert(round_player_2.ready_state, 'player_2 should be ready');

    // Verify player_1's total rounds count has been incremented
    let player_stat_1: PlayerStats = world.read_model(player_1);
    assert(player_stat_1.total_rounds == 1, 'player_1 total_rounds == 1');

    // Verify player_2's total rounds count has been incremented
    let player_stat_2: PlayerStats = world.read_model(player_2);
    assert(player_stat_2.total_rounds == 1, 'player_2 total_rounds == 1');
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/tests/test_utils.cairo ###
Type: cairo
Lines:       55
Size: 2171 bytes

```cairo
use dojo_cairo_test::{
    ContractDef, ContractDefTrait, NamespaceDef, TestResource, WorldStorageTestTrait,
    spawn_test_world,
};
use dojo::world::{WorldStorage, WorldStorageTrait};

use lyricsflip::models::config::{m_GameConfig};
use lyricsflip::models::round::{m_Rounds, m_RoundsCount, m_RoundPlayer, m_PlayerStats};
use lyricsflip::systems::actions::{actions};
use lyricsflip::systems::config::{game_config};
use lyricsflip::models::card::{m_LyricsCard, m_LyricsCardCount, m_YearCards, m_ArtistCards};

pub fn namespace_def() -> NamespaceDef {
    let ndef = NamespaceDef {
        namespace: "lyricsflip",
        resources: [
            TestResource::Model(m_Rounds::TEST_CLASS_HASH),
            TestResource::Model(m_RoundsCount::TEST_CLASS_HASH),
            TestResource::Model(m_RoundPlayer::TEST_CLASS_HASH),
            TestResource::Model(m_LyricsCard::TEST_CLASS_HASH),
            TestResource::Model(m_LyricsCardCount::TEST_CLASS_HASH),
            TestResource::Model(m_YearCards::TEST_CLASS_HASH),
            TestResource::Model(m_GameConfig::TEST_CLASS_HASH),
            TestResource::Model(m_ArtistCards::TEST_CLASS_HASH),
            TestResource::Model(m_PlayerStats::TEST_CLASS_HASH),
            TestResource::Event(actions::e_RoundCreated::TEST_CLASS_HASH),
            TestResource::Event(actions::e_RoundJoined::TEST_CLASS_HASH),
            TestResource::Event(actions::e_PlayerReady::TEST_CLASS_HASH),
            TestResource::Contract(actions::TEST_CLASS_HASH),
            TestResource::Contract(game_config::TEST_CLASS_HASH),
        ]
            .span(),
    };

    ndef
}

pub fn contract_defs() -> Span<ContractDef> {
    [
        ContractDefTrait::new(@"lyricsflip", @"actions")
            .with_writer_of([dojo::utils::bytearray_hash(@"lyricsflip")].span()),
        ContractDefTrait::new(@"lyricsflip", @"game_config")
            .with_writer_of([dojo::utils::bytearray_hash(@"lyricsflip")].span()),
    ]
        .span()
}


pub fn setup() -> WorldStorage {
    let ndef = namespace_def();
    let mut world: WorldStorage = spawn_test_world([ndef].span());
    world.sync_perms_and_inits(contract_defs());

    world
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/models/round.cairo ###
Type: cairo
Lines:       83
Size: 1890 bytes

```cairo
use starknet::{ContractAddress};

#[derive(Copy, Drop, Serde, Debug)]
#[dojo::model]
pub struct RoundsCount {
    #[key]
    pub id: felt252, // represents GAME_ID
    pub count: u256,
}

#[derive(Copy, Drop, Serde, Debug)]
#[dojo::model]
pub struct Rounds {
    #[key]
    pub round_id: u256,
    pub round: Round,
}

#[derive(Copy, Drop, Serde, Debug)]
#[dojo::model]
pub struct RoundPlayer {
    #[key]
    pub player_to_round_id: (ContractAddress, u256),
    pub joined: bool,
    pub ready_state: bool,
}


#[derive(Copy, Drop, Serde, Introspect, Debug)]
pub enum RoundState {
    Pending,
    Started,
    Completed,
}

#[derive(Copy, Drop, Serde, IntrospectPacked, Debug)]
pub struct Round {
    pub creator: ContractAddress,
    pub genre: felt252,
    pub wager_amount: u256,
    pub start_time: u64,
    pub state: felt252,
    pub end_time: u64,
    pub next_card_index: u8,
    pub players_count: u256,
    pub ready_players_count: u256,
}

impl RoundStateIntoFelt252 of Into<RoundState, felt252> {
    fn into(self: RoundState) -> felt252 {
        match self {
            RoundState::Pending => 'PENDING',
            RoundState::Started => 'STARTED',
            RoundState::Completed => 'COMPLETED',
        }
    }
}

impl Felt252TryIntoRoundState of TryInto<felt252, RoundState> {
    fn try_into(self: felt252) -> Option<RoundState> {
        if self == 'PENDING' {
            Option::Some(RoundState::Pending)
        } else if self == 'STARTED' {
            Option::Some(RoundState::Started)
        } else if self == 'COMPLETED' {
            Option::Some(RoundState::Completed)
        } else {
            Option::None
        }
    }
}


#[derive(Copy, Drop, Serde, Debug)]
#[dojo::model]
pub struct PlayerStats {
    #[key]
    player: ContractAddress,
    pub total_rounds: u64,
    pub rounds_won: u64,
    pub current_streak: u64,
    pub max_streak: u64,
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/models/config.cairo ###
Type: cairo
Lines:       10
Size: 234 bytes

```cairo
use starknet::ContractAddress;

#[derive(Copy, Drop, Serde, Debug)]
#[dojo::model]
pub struct GameConfig {
    #[key]
    pub id: felt252, // represents GAME_ID 
    pub cards_per_round: u32,
    pub admin_address: ContractAddress,
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/models/card.cairo ###
Type: cairo
Lines:       35
Size: 667 bytes

```cairo
#[derive(Clone, Drop, Serde, Debug)]
#[dojo::model]
pub struct LyricsCard {
    #[key]
    pub card_id: u256,
    pub genre: felt252,
    pub artist: felt252,
    pub title: felt252,
    pub year: u64,
    pub lyrics: ByteArray,
}

#[derive(Copy, Drop, Serde, Debug)]
#[dojo::model]
pub struct LyricsCardCount {
    #[key]
    pub id: felt252, // represents GAME_ID
    pub count: u256,
}

#[derive(Clone, Drop, Serde, Debug)]
#[dojo::model]
pub struct YearCards {
    #[key]
    pub year: u64,
    pub cards: Span<u256>,
}

#[derive(Clone, Drop, Serde, Debug)]
#[dojo::model]
pub struct ArtistCards {
    #[key]
    pub artist: felt252,
    pub cards: Span<u256>,
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/alias.cairo ###
Type: cairo
Lines:        1
Size: 20 bytes

```cairo
pub type ID = u256;
```

----------------------------------------


### File: documents/lyricsflip_contract/src/constants.cairo ###
Type: cairo
Lines:        1
Size: 35 bytes

```cairo
pub const GAME_ID: felt252 = 'v0';
```

----------------------------------------


### File: documents/lyricsflip_contract/src/lib.cairo ###
Type: cairo
Lines:       11
Size: 150 bytes

```cairo
pub mod models;
pub mod systems;
pub mod alias;
pub mod constants;
pub mod genre;

#[cfg(test)]
mod tests {
    mod test_world;
    mod test_utils;
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/systems/actions.cairo ###
Type: cairo
Lines:      317
Size: 11479 bytes

```cairo
use lyricsflip::alias::ID;
use lyricsflip::genre::Genre;
use starknet::ContractAddress;
use core::array::{ArrayTrait, SpanTrait};
use dojo::model::ModelStorage;
use dojo::event::EventStorage;

#[starknet::interface]
pub trait IActions<TContractState> {
    fn create_round(ref self: TContractState, genre: Genre) -> ID;
    fn join_round(ref self: TContractState, round_id: u256);
    fn get_round_id(self: @TContractState) -> ID;
    fn add_lyrics_card(
        ref self: TContractState,
        genre: Genre,
        artist: felt252,
        title: felt252,
        year: u64,
        lyrics: ByteArray,
    ) -> u256;
    fn is_round_player(self: @TContractState, round_id: u256, player: ContractAddress) -> bool;
    fn start_round(ref self: TContractState, round_id: u256);
}

// dojo decorator
#[dojo::contract]
pub mod actions {
    use lyricsflip::models::card::{LyricsCard, LyricsCardCount, YearCards, ArtistCards};
    use lyricsflip::constants::{GAME_ID};
    use lyricsflip::genre::{Genre};
    use lyricsflip::models::round::{
        Round, RoundState, Rounds, RoundsCount, RoundPlayer, PlayerStats,
    };

    use core::num::traits::Zero;

    use dojo::event::EventStorage;
    use dojo::model::ModelStorage;
    use dojo::world::WorldStorage;
    use core::array::{ArrayTrait, SpanTrait};
    use starknet::{ContractAddress, get_block_timestamp, get_caller_address};
    use super::{IActions, ID};

    #[derive(Drop, Copy, Serde)]
    #[dojo::event]
    pub struct RoundCreated {
        #[key]
        pub round_id: u256,
        pub creator: ContractAddress,
    }

    #[derive(Drop, Copy, Serde)]
    #[dojo::event]
    pub struct RoundJoined {
        #[key]
        pub round_id: u256,
        pub player: ContractAddress,
    }

    #[derive(Drop, Copy, Serde)]
    #[dojo::event]
    pub struct PlayerReady {
        #[key]
        pub round_id: u256,
        #[key]
        pub player: ContractAddress,
        pub ready_time: u64,
    }

    #[abi(embed_v0)]
    impl ActionsImpl of IActions<ContractState> {
        fn create_round(ref self: ContractState, genre: Genre) -> ID {
            // Get the default world.
            let mut world = self.world_default();

            // get caller address
            let caller = get_caller_address();

            // get the next round ID
            let round_id = self.get_round_id();

            // new round
            let round = Round {
                creator: caller,
                genre: genre.into(),
                wager_amount: 0, //TODO
                start_time: get_block_timestamp(), //TODO
                state: RoundState::Pending.into(),
                end_time: 0, //TODO
                next_card_index: 0,
                players_count: 1,
                ready_players_count: 0,
            };

            // write new round count to world
            world.write_model(@RoundsCount { id: GAME_ID, count: round_id });
            // write new round to world
            world.write_model(@Rounds { round_id, round });
            // write round player to world
            world
                .write_model(
                    @RoundPlayer {
                        player_to_round_id: (caller, round_id), joined: true, ready_state: false,
                    },
                );

            world.emit_event(@RoundCreated { round_id, creator: caller });

            round_id
        }

        fn join_round(ref self: ContractState, round_id: u256) {
            // Get the default world.
            let mut world = self.world_default();

            // get caller address
            let caller = get_caller_address();

            // read the model from the world
            let mut rounds: Rounds = world.read_model(round_id);

            // read round player from world
            let round_player: RoundPlayer = world.read_model((caller, round_id));

            // check if round exists by checking if no player exists
            assert(rounds.round.players_count > 0, 'Round does not exist');

            // check that round is not started
            assert(rounds.round.state == RoundState::Pending.into(), 'Round has started');

            // assert that player has not joined round
            assert(!round_player.joined, 'Already joined round');

            rounds.round.players_count = rounds.round.players_count + 1;

            // update round in world
            world.write_model(@rounds);

            // write round player to world
            world
                .write_model(
                    @RoundPlayer {
                        player_to_round_id: (caller, round_id), joined: true, ready_state: false,
                    },
                );

            // emit round created event
            world.emit_event(@RoundJoined { round_id, player: caller });
        }

        fn get_round_id(self: @ContractState) -> ID {
            // Get the default world
            let world = self.world_default();

            // compute next round ID from round counts
            let rounds_count: RoundsCount = world.read_model(GAME_ID);
            rounds_count.count + 1
        }

        fn add_lyrics_card(
            ref self: ContractState,
            genre: Genre,
            artist: felt252,
            title: felt252,
            year: u64,
            lyrics: ByteArray,
        ) -> u256 {
            let mut world = self.world_default();

            let card_count: LyricsCardCount = world.read_model(GAME_ID);
            let card_id = card_count.count + 1;

            let new_card = LyricsCard { card_id, genre: genre.into(), artist, title, year, lyrics };
            world.write_model(@new_card);

            world.write_model(@LyricsCardCount { id: GAME_ID, count: card_id });

            CardGroupTrait::add_year_cards(ref world, year, card_id);
            CardGroupTrait::add_artist_cards(ref world, artist, card_id);

            card_id
        }

        fn is_round_player(self: @ContractState, round_id: u256, player: ContractAddress) -> bool {
            // Get the default world.
            let world = self.world_default();
            // Get the round player
            let round_player: RoundPlayer = world.read_model((player, round_id));

            // Return the joined boolean which signifies if the player is a participant of the round
            // or not
            round_player.joined
        }

        /// Initiates a game round after a player signals readiness.
        ///
        /// This function handles the process of a player signaling they are ready to start the
        /// round.
        /// It validates the player's participation, updates their ready state, and checks if all
        /// players are ready to begin the round.
        ///
        /// @param round_id - The unique identifier for the round
        fn start_round(ref self: ContractState, round_id: u256) {
            // Get access to the world state
            let mut world = self.world_default();

            // Validate that the round exists and is in a valid state
            self.is_valid_round(@world, round_id);

            // Load the round data from the world state
            let rounds: Rounds = world.read_model(round_id);
            let mut round = rounds.round;

            // Get the address of the caller (the player signaling readiness)
            let caller = get_caller_address();

            // Check if caller is authorized - must be either the creator or a participant
            let is_creator = round.creator == caller;
            let is_participant = self.is_round_player(round_id, caller);
            assert(is_creator || is_participant, 'Caller is non participant');

            // Verify caller hasn't already signaled readiness
            let mut round_player: RoundPlayer = world.read_model((caller, round_id));
            assert(round_player.ready_state == false, 'Already signaled readiness');

            // Update the player's statistics to reflect participation in this round
            let mut player_stats: PlayerStats = world.read_model(caller);
            player_stats.total_rounds = player_stats.total_rounds + 1;
            world.write_model(@player_stats);

            // Mark the player as ready
            round_player.ready_state = true;
            world.write_model(@round_player);

            // Increment the count of ready players in the round
            round.ready_players_count = round.ready_players_count + 1;
            world.write_model(@Rounds { round_id, round });

            // Emit an event to log that the player is ready
            world
                .emit_event(
                    @PlayerReady { round_id, player: caller, ready_time: get_block_timestamp() },
                );

            // Check if all players are now ready
            let mut rounds: Rounds = world.read_model(round_id);
            if rounds.round.ready_players_count == rounds.round.players_count {
                // If all players are ready, update the round state to Started
                rounds.round.state = RoundState::Started.into();
                world.write_model(@rounds);
            }
        }
    }


    #[generate_trait]
    impl InternalImpl of InternalTrait {
        /// Use the default namespace "dojo_starter". This function is handy since the ByteArray
        /// can't be const.
        fn world_default(self: @ContractState) -> WorldStorage {
            self.world(@"lyricsflip")
        }

        fn is_valid_round(self: @ContractState, world: @WorldStorage, round_id: u256) -> bool {
            let round: Rounds = world.read_model(round_id);
            !round.round.creator.is_zero()
        }
    }

    #[generate_trait]
    impl CardGroupImpl of CardGroupTrait {
        fn add_year_cards(ref world: WorldStorage, year: u64, card_id: u256) {
            let mut year_cards = YearCards { year, cards: ArrayTrait::new().span() };
            let existing_year_cards: YearCards = world.read_model(year);
            if existing_year_cards.year != 0 {
                year_cards = existing_year_cards;
            }

            let mut new_cards: Array<u256> = ArrayTrait::new();
            let mut i = 0;
            loop {
                if i >= year_cards.cards.len() {
                    break;
                }
                new_cards.append(*year_cards.cards[i]);
                i += 1;
            };
            new_cards.append(card_id);

            let updated_year_cards = YearCards { year, cards: new_cards.span() };
            world.write_model(@updated_year_cards);
        }

        fn add_artist_cards(ref world: WorldStorage, artist: felt252, card_id: u256) {
            let mut artist_cards = ArtistCards { artist, cards: ArrayTrait::new().span() };
            let existing_artist_cards: ArtistCards = world.read_model(artist);
            if existing_artist_cards.artist.is_zero() {
                artist_cards = existing_artist_cards;
            }

            let mut new_cards: Array<u256> = ArrayTrait::new();
            let mut i = 0;
            loop {
                if i >= artist_cards.cards.len() {
                    break;
                }
                new_cards.append(*artist_cards.cards[i]);
                i += 1;
            };
            new_cards.append(card_id);

            let updated_artist_cards = ArtistCards { artist, cards: new_cards.span() };
            world.write_model(@updated_artist_cards);
        }
    }
}

```

----------------------------------------


### File: documents/lyricsflip_contract/src/systems/config.cairo ###
Type: cairo
Lines:       80
Size: 2846 bytes

```cairo
use lyricsflip::genre::Genre;
use starknet::ContractAddress;

#[starknet::interface]
pub trait IGameConfig<TContractState> {
    //TODO
    fn set_game_config(ref self: TContractState, admin_address: ContractAddress);
    fn set_cards_per_round(ref self: TContractState, cards_per_round: u32);
    fn set_admin_address(ref self: TContractState, admin_address: ContractAddress);
}

// dojo decorator
#[dojo::contract]
pub mod game_config {
    use core::num::traits::zero::Zero;
    use dojo::event::EventStorage;
    use dojo::model::{Model, ModelStorage};
    use dojo::world::{IWorldDispatcherTrait, WorldStorage};
    use lyricsflip::constants::GAME_ID;
    use lyricsflip::models::config::GameConfig;
    use starknet::{ContractAddress, get_block_timestamp, get_caller_address};
    use super::IGameConfig;

    pub fn check_caller_is_admin(world: WorldStorage) -> bool {
        let mut game_config: GameConfig = world.read_model(GAME_ID);
        let mut admin_address = game_config.admin_address;
        get_caller_address() == admin_address
    }

    pub fn assert_caller_is_admin(world: WorldStorage) {
        assert(check_caller_is_admin(world), 'caller not admin');
    }


    #[abi(embed_v0)]
    impl GameConfigImpl of IGameConfig<ContractState> {
        //TODO
        fn set_game_config(ref self: ContractState, admin_address: ContractAddress) {}

        fn set_cards_per_round(ref self: ContractState, cards_per_round: u32) {
            // Get the world dispatcher
            let mut world = self.world_default();

            assert_caller_is_admin(world);

            // Check that the value being set is non-zero
            assert(cards_per_round != 0, 'cards_per_round cannot be zero');

            // Get the current game config
            let mut game_config: GameConfig = world.read_model(GAME_ID);

            // Update the cards_per_round field
            game_config.cards_per_round = cards_per_round;

            // Save the updated game config back to the world
            world.write_model(@game_config);
        }

        fn set_admin_address(ref self: ContractState, admin_address: ContractAddress) {
            assert(
                admin_address != Zero::<ContractAddress>::zero(), 'admin_address cannot be zero',
            );

            let mut world = self.world_default();
            let mut game_config: GameConfig = world.read_model(GAME_ID);

            game_config.admin_address = admin_address;
            world.write_model(@game_config);
        }
    }

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        /// Use the default namespace "dojo_starter". This function is handy since the ByteArray
        /// can't be const.
        fn world_default(self: @ContractState) -> dojo::world::WorldStorage {
            self.world(@"lyricsflip")
        }
    }
}
```

----------------------------------------


### File: documents/lyricsflip_contract/src/genre.cairo ###
Type: cairo
Lines:       70
Size: 2011 bytes

```cairo
#[derive(Drop, Copy, Serde, PartialEq, Introspect, Debug)]
pub enum Genre {
    HipHop,
    Pop,
    Rock,
    RnB,
    Electronic,
    Classical,
    Jazz,
    Country,
    Blues,
    Reggae,
    Afrobeat,
    Gospel,
    Folk,
}

impl GenreIntoFelt252 of Into<Genre, felt252> {
    fn into(self: Genre) -> felt252 {
        match self {
            Genre::HipHop => 'HipHop',
            Genre::Pop => 'Pop',
            Genre::Rock => 'Rock',
            Genre::RnB => 'RnB',
            Genre::Electronic => 'Electronic',
            Genre::Classical => 'Classical',
            Genre::Jazz => 'Jazz',
            Genre::Country => 'Country',
            Genre::Reggae => 'Reggae',
            Genre::Blues => 'Blues',
            Genre::Afrobeat => 'Afrobeat',
            Genre::Gospel => 'Gospel',
            Genre::Folk => 'Folk',
        }
    }
}

impl Felt252TryIntoGenre of TryInto<felt252, Genre> {
    fn try_into(self: felt252) -> Option<Genre> {
        if self == 'HipHop' {
            Option::Some(Genre::HipHop)
        } else if self == 'Pop' {
            Option::Some(Genre::Pop)
        } else if self == 'Rock' {
            Option::Some(Genre::Rock)
        } else if self == 'RnB' {
            Option::Some(Genre::RnB)
        } else if self == 'Electronic' {
            Option::Some(Genre::Electronic)
        } else if self == 'Classical' {
            Option::Some(Genre::Classical)
        } else if self == 'Jazz' {
            Option::Some(Genre::Jazz)
        } else if self == 'Country' {
            Option::Some(Genre::Country)
        } else if self == 'Reggae' {
            Option::Some(Genre::Reggae)
        } else if self == 'Blues' {
            Option::Some(Genre::Blues)
        } else if self == 'Afrobeat' {
            Option::Some(Genre::Afrobeat)
        } else if self == 'Gospel' {
            Option::Some(Genre::Gospel)
        } else if self == 'Folk' {
            Option::Some(Genre::Folk)
        } else {
            Option::None
        }
    }
}
```

----------------------------------------

